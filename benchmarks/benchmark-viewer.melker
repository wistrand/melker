<melker>
  <title>Benchmark Viewer</title>

  <policy>{"permissions": {"read": ["."]}}</policy>

  <script>
    // Benchmark data storage
    let results = [];
    let findings = []; // Key findings from benchmark analysis
    let notes = '';    // Free-form notes
    let history = []; // Multiple result sets for history view
    let categories = [];
    let selectedCategory = 'all';

    // Multi-suite comparison
    let relatedFiles = [];  // [{date, commit, path, results, findings, notes}, ...]
    let baseName = '';       // Suite base name (e.g., 'ansi-output')
    let baselineIdx = 0;    // Index into sorted relatedFiles for baseline
    let compareIdx = -1;    // Index into sorted relatedFiles for compare-to (-1 = last)

    // Load results from JSON file
    export async function loadFile(event) {
      try {
        const content = await Deno.readTextFile(event.path);
        const data = JSON.parse(content);

        if (data.results && Array.isArray(data.results)) {
          results = data.results;
          findings = data.findings || [];
          notes = data.notes || '';
          history.push({
            timestamp: data.timestamp || new Date().toISOString(),
            commit: data.commit || 'unknown',
            results: data.results,
            findings: data.findings,
            notes: data.notes,
          });

          // Extract categories
          const cats = new Set(results.map(r => r.category || 'uncategorized'));
          categories = ['all', ...Array.from(cats).sort()];

          // Auto-discover related files for comparison
          await discoverRelatedFiles(event.path);
          baselineIdx = 0;
          compareIdx = -1; // -1 = latest

          updateViews();
          const findingsCount = findings.length > 0 ? `, ${findings.length} findings` : '';
          const suiteInfo = relatedFiles.length >= 2
            ? ` | ${baseName} (${relatedFiles.length} dates found)`
            : '';
          $melker.getElementById('status').props.text =
            `Loaded ${results.length} benchmarks${findingsCount} from ${event.path.split('/').pop()}${suiteInfo}`;
        } else {
          $melker.getElementById('status').props.text = 'Invalid benchmark format';
        }
      } catch (err) {
        $melker.getElementById('status').props.text = `Error: ${err.message}`;
      }

      // Close file dialog
      $melker.getElementById('fileDialog').hide();
    }

    // Discover related benchmark files in the same directory
    // Supports both old (suite-YYYY-MM-DD.json) and new (suite-YYYY-MM-DDTHH-MM.json) formats
    const filePattern = /^(.+)-(\d{4}-\d{2}-\d{2}(?:T\d{2}-\d{2})?)\.json$/;

    async function discoverRelatedFiles(filePath) {
      const fileName = filePath.split('/').pop();
      const dirPath = filePath.slice(0, filePath.length - fileName.length);
      const match = fileName.match(filePattern);
      if (!match) {
        baseName = '';
        relatedFiles = [];
        return;
      }

      baseName = match[1];
      relatedFiles = [];

      try {
        for await (const entry of Deno.readDir(dirPath || '.')) {
          if (!entry.isFile) continue;
          const m = entry.name.match(filePattern);
          if (!m || m[1] !== baseName) continue;

          const path = dirPath ? dirPath + entry.name : entry.name;
          try {
            const raw = await Deno.readTextFile(path);
            const d = JSON.parse(raw);
            if (d.results && Array.isArray(d.results)) {
              relatedFiles.push({
                date: m[2],
                commit: d.commit || 'unknown',
                path,
                results: d.results,
                findings: d.findings || [],
                notes: d.notes || '',
              });
            }
          } catch { /* skip unreadable files */ }
        }
        relatedFiles.sort((a, b) => a.date.localeCompare(b.date));
      } catch { /* directory read failed */ }
    }

    // Update all views with current data
    function updateViews() {
      updateSummaryTable();
      updateHistoryHeatmap();
      updateCategorySelect();
      updateFindings();
      updateCompare();
    }

    // Findings tooltip handler
    export function findingsTooltip(event) {
      if (!event.context || event.context.row < 0) return undefined;
      const finding = findings[event.context.row];
      if (!finding) return undefined;

      const severity = finding.severity || 'info';
      const category = finding.category || 'general';
      return `**${finding.title}**\n\n` +
        `_${severity.toUpperCase()}_ | ${category}\n\n` +
        finding.description;
    }

    // Findings table
    function updateFindings() {
      const rows = findings.map(f => [
        f.title,
        f.category || 'info',
        f.severity || 'info',
        f.description.slice(0, 60) + (f.description.length > 60 ? '...' : ''),
      ]);

      const table = $melker.getElementById('findingsTable');
      if (table) {
        table.props.rows = rows;
      }

      // Update notes
      const notesEl = $melker.getElementById('notesText');
      if (notesEl) {
        notesEl.props.text = notes || 'No notes available.';
      }
    }

    // Summary table
    function updateSummaryTable() {
      const filtered = selectedCategory === 'all'
        ? results
        : results.filter(r => r.category === selectedCategory);

      const rows = filtered.map(r => {
        const target = r.target;
        const status = target !== undefined ? (r.median <= target ? 'PASS' : 'FAIL') : '-';
        return [
          r.name,
          r.category || '-',
          `${r.median.toFixed(2)}${r.unit || 'ms'}`,
          `${r.p95.toFixed(2)}`,
          `${r.p99.toFixed(2)}`,
          target !== undefined ? `${target}${r.unit || 'ms'}` : '-',
          status,
        ];
      });

      const table = $melker.getElementById('summaryTable');
      table.props.rows = rows;
    }

    // Percentile heatmap - shows median/p95/p99 for each benchmark
    function updateHistoryHeatmap() {
      if (results.length === 0) return;

      const filtered = selectedCategory === 'all'
        ? results
        : results.filter(r => r.category === selectedCategory);

      // Build grid: rows = benchmarks, cols = [median, p95, p99]
      const grid = filtered.map(r => [r.median, r.p95, r.p99]);
      const rowLabels = filtered.map(r => r.name.slice(0, 24));
      const colLabels = ['Median', 'p95', 'p99'];

      const heatmap = $melker.getElementById('historyHeatmap');
      heatmap.props.grid = grid;
      heatmap.props.rowLabels = rowLabels;
      heatmap.props.colLabels = colLabels;
    }

    // Comparison tab
    function getSortedFiles() {
      return relatedFiles.slice().sort((a, b) => a.date.localeCompare(b.date));
    }

    function computeComparison() {
      if (relatedFiles.length < 2) return [];
      const sorted = getSortedFiles();
      const bi = Math.max(0, Math.min(baselineIdx, sorted.length - 1));
      const ci = compareIdx < 0 ? sorted.length - 1 : Math.max(0, Math.min(compareIdx, sorted.length - 1));
      const baseline = sorted[bi];
      const current = sorted[ci];
      const benchNames = current.results.map(r => r.name);

      return benchNames.map(name => {
        const values = sorted.map(f => {
          const r = f.results.find(x => x.name === name);
          return r ? r.median : null;
        });
        const baseResult = baseline.results.find(x => x.name === name);
        const curResult = current.results.find(x => x.name === name);
        const baseVal = baseResult?.median;
        const curVal = curResult?.median;
        let diff = null;
        let diffPercent = null;
        let status = '-';
        if (baseVal != null && curVal != null && baseVal > 0) {
          diff = curVal - baseVal;
          diffPercent = ((curVal - baseVal) / baseVal) * 100;
          if (diffPercent < -5) status = 'faster';
          else if (diffPercent > 5) status = 'slower';
          else status = 'same';
        }

        // Assess signal quality
        let signal = '';
        if (baseVal != null && curVal != null) {
          if (baseVal < 0.01 && curVal < 0.01) {
            signal = 'noise';
          } else {
            const baseRatio = baseResult?.p95 && baseVal > 0 ? baseResult.p95 / baseVal : 1;
            const curRatio = curResult?.p95 && curVal > 0 ? curResult.p95 / curVal : 1;
            if (baseRatio > 3 || curRatio > 3) signal = 'noisy';
          }
        }

        return { name, values, diff, diffPercent, status, signal };
      });
    }

    export function onBaselineChange(event) {
      baselineIdx = parseInt(event.value, 10);
      updateCompare();
    }

    export function onCompareChange(event) {
      compareIdx = parseInt(event.value, 10);
      updateCompare();
    }

    function updateCompareSelects(sorted) {
      const baselineSel = $melker.getElementById('baselineSelect');
      const compareSel = $melker.getElementById('compareSelect');
      if (!baselineSel || !compareSel) return;

      const options = sorted.map((f, i) => ({ id: String(i), label: f.date, disabled: false }));
      baselineSel.props.options = options;
      compareSel.props.options = options;

      const bi = Math.max(0, Math.min(baselineIdx, sorted.length - 1));
      const ci = compareIdx < 0 ? sorted.length - 1 : Math.max(0, Math.min(compareIdx, sorted.length - 1));
      baselineSel.props.selectedValue = String(bi);
      compareSel.props.selectedValue = String(ci);
    }

    function updateCompare() {
      const statusEl = $melker.getElementById('compareStatus');
      const table = $melker.getElementById('compareTable');
      const heatmap = $melker.getElementById('compareHeatmap');

      if (relatedFiles.length < 2) {
        if (statusEl) statusEl.props.text = 'No comparison data (need 2+ dates for the same suite)';
        if (table) { table.props.columns = []; table.props.rows = []; }
        if (heatmap) heatmap.props.grid = [];
        return;
      }

      const sorted = getSortedFiles();
      const dates = sorted.map(f => f.date);
      updateCompareSelects(sorted);

      const bi = Math.max(0, Math.min(baselineIdx, sorted.length - 1));
      const ci = compareIdx < 0 ? sorted.length - 1 : Math.max(0, Math.min(compareIdx, sorted.length - 1));
      if (statusEl) statusEl.props.text = `${baseName}: ${sorted[bi].date} vs ${sorted[ci].date}`;

      // Build comparison table
      const comparison = computeComparison();
      const numericSort = (a, b) => {
        const na = parseFloat(String(a).replace('%', ''));
        const nb = parseFloat(String(b).replace('%', ''));
        if (isNaN(na) && isNaN(nb)) return 0;
        if (isNaN(na)) return 1;
        if (isNaN(nb)) return -1;
        return na - nb;
      };
      const columns = [
        { header: 'Benchmark', width: 'fill' },
        ...dates.map(d => ({ header: d, width: 12, align: 'right', comparator: numericSort })),
        { header: 'Diff %', width: 10, align: 'right', comparator: numericSort },
        { header: 'Status', width: 8 },
        { header: 'Signal', width: 8 },
      ];
      const rows = comparison.map(c => [
        c.name,
        ...c.values.map(v => v != null ? v.toFixed(2) : '-'),
        c.diffPercent != null ? `${c.diffPercent >= 0 ? '+' : ''}${c.diffPercent.toFixed(1)}%` : '-',
        c.status,
        c.signal,
      ]);
      if (table) {
        table.props.columns = columns;
        table.props.rows = rows;
      }

      // Build heatmap
      const benchNames = sorted[0].results.map(r => r.name);
      const grid = benchNames.map(name =>
        sorted.map(f => f.results.find(r => r.name === name)?.median ?? null)
      );
      const colLabels = dates;
      const rowLabels = benchNames.map(n => n.slice(0, 24));
      if (heatmap) {
        heatmap.props.grid = grid;
        heatmap.props.colLabels = colLabels;
        heatmap.props.rowLabels = rowLabels;
      }
    }

    // Category select
    function updateCategorySelect() {
      // Update would require recreating options, skip for now
    }

    // Filter by category
    export function onCategoryChange(event) {
      selectedCategory = event.value;
      updateSummaryTable();
      updateHistoryHeatmap();
    }

    // Open file dialog
    export function openFileDialog() {
      $melker.getElementById('fileDialog').show();
    }

    // Close file dialog
    export function closeFileDialog() {
      $melker.getElementById('fileDialog').hide();
    }

    // Clear all data
    export function clearData() {
      results = [];
      findings = [];
      notes = '';
      history = [];
      categories = ['all'];
      selectedCategory = 'all';
      relatedFiles = [];
      baseName = '';
      baselineIdx = 0;
      compareIdx = -1;

      $melker.getElementById('summaryTable').props.rows = [];
      $melker.getElementById('historyHeatmap').props.grid = [];
      const findingsTable = $melker.getElementById('findingsTable');
      if (findingsTable) findingsTable.props.rows = [];
      const notesText = $melker.getElementById('notesText');
      if (notesText) notesText.props.text = 'No notes available.';
      const compareTable = $melker.getElementById('compareTable');
      if (compareTable) { compareTable.props.columns = []; compareTable.props.rows = []; }
      const compareHeatmap = $melker.getElementById('compareHeatmap');
      if (compareHeatmap) compareHeatmap.props.grid = [];
      const compareStatus = $melker.getElementById('compareStatus');
      if (compareStatus) compareStatus.props.text = 'No comparison data';
      $melker.getElementById('status').props.text = 'Data cleared';
    }
  </script>

  <container style="height: fill; padding: 1; gap: 1;">
    <container style="flex-direction: row; gap: 2; align-items: center;">
      <text style="font-weight: bold;">Benchmark Viewer</text>
      <button label="Load File" onClick="$app.openFileDialog();" />
      <button label="Clear" onClick="$app.clearData();" />
      <container style="flex: 1;" />
      <text id="status">No data loaded</text>
    </container>

    <tabs style="flex: 1;">
      <tab title="Summary">
        <container style="gap: 1; flex: 1;">
          <container style="flex-direction: row; gap: 1; align-items: center;">
            <text>Category:</text>
            <select id="categorySelect" selectedValue="all" onSelect="$app.onCategoryChange(event);">
              <option value="all">All</option>
              <option value="rendering">Rendering</option>
              <option value="layout">Layout</option>
              <option value="components">Components</option>
              <option value="graphics">Graphics</option>
              <option value="bundler">Bundler</option>
            </select>
          </container>
          <data-table id="summaryTable" style="flex: 1;">
          {
            "columns": [
              {"header": "Benchmark", "width": "fill"},
              {"header": "Category", "width": 12},
              {"header": "Median", "width": 12, "align": "right"},
              {"header": "p95", "width": 10, "align": "right"},
              {"header": "p99", "width": 10, "align": "right"},
              {"header": "Target", "width": 12, "align": "right"},
              {"header": "Status", "width": 8}
            ],
            "rows": []
          }
          </data-table>
        </container>
      </tab>

      <tab title="Percentiles">
        <container style="padding: 1; gap: 1; flex: 1;">
          <text style="font-weight: bold;">Percentile Distribution (Median / p95 / p99)</text>
          <container style="flex: 1; overflow: auto;">
            <data-heatmap
              id="historyHeatmap"
              grid='[]'
              colorScale="thermal"
              showValues="true"
              valueFormat=".2f"
              style="cellWidth: 8;"
            />
          </container>
        </container>
      </tab>

      <tab title="Compare">
        <container style="gap: 1; flex: 1;">
          <container style="flex-direction: row; gap: 2; align-items: center;">
            <text>Baseline:</text>
            <select id="baselineSelect" onSelect="$app.onBaselineChange(event);">
              <option value="0">-</option>
            </select>
            <text>Compare to:</text>
            <select id="compareSelect" onSelect="$app.onCompareChange(event);">
              <option value="0">-</option>
            </select>
            <container style="flex: 1;" />
            <text id="compareStatus" style="font-weight: bold;">No comparison data</text>
          </container>
          <data-table id="compareTable" style="flex: 1;">
          {
            "columns": [],
            "rows": []
          }
          </data-table>
          <container style="height: 12; overflow: auto;">
            <data-heatmap id="compareHeatmap" grid='[]' colorScale="diverging"
              showValues="true" valueFormat=".2f" style="cellWidth: 8;" />
          </container>
        </container>
      </tab>

      <tab title="Findings">
        <container style="padding: 1; gap: 1; flex: 1;">
          <text style="font-weight: bold;">Key Findings</text>
          <container style="flex: 1; overflow: auto;">
            <data-table id="findingsTable" style="flex: 1;" onTooltip="$app.findingsTooltip(event)">
            {
              "columns": [
                {"header": "Finding", "width": "fill"},
                {"header": "Category", "width": 14},
                {"header": "Severity", "width": 10},
                {"header": "Description", "width": 60}
              ],
              "rows": []
            }
            </data-table>
          </container>
          <container style="height: 8; border: single; padding: 1; overflow: auto;">
            <text style="font-weight: bold;">Notes:</text>
            <text id="notesText" style="color: gray; text-wrap: wrap;">No notes available.</text>
          </container>
        </container>
      </tab>
    </tabs>
  </container>

  <dialog id="fileDialog" title="Load Benchmark Results" open="false" modal="true" width="70" height="20">
    <file-browser
      id="fileBrowser"
      extensions='[".json"]'
      onSelect="$app.loadFile(event);"
      onCancel="$app.closeFileDialog();"
      selectLabel="Load"
      maxVisible="12"
    />
  </dialog>

  <script type="typescript" async="ready">
    // Auto-load: if file argument passed, load it
    const fileArg = '${argv[1]:-}'.trim();
    if (fileArg && fileArg.endsWith('.json')) {
      await $app.loadFile({ path: fileArg });
      $melker.render();
    }
  </script>
</melker>
