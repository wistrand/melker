<melker>
  <container style="width: fill; height: fill; border: thin; padding: 1; display: flex; flex-direction: column; background-color: black; color: white;">

    <!-- Header -->
    <container style="display: flex; flex-direction: row; justify-content: space-between; align-items: center; border-bottom: thin; border-color: gray;">
      <text style="font-weight: bold; color: cyan; text-align: left;">âš¡ Enterprise Analog Clock v1.0.0</text>
      <text id="timezoneDisplay" style="color: yellow; text-align: right;">Zone: UTC</text>
    </container>

    <!-- Main clock area -->
    <container style="width: fill; height: fill; display: flex; align-items: center; justify-content: center; border: thin; border-color: gray;">
      <canvas
        id="clockCanvas"
        width="48"
        height="12"
        style="width: fill; height: fill; background-color: black;"
        onPaint="$app.drawAnalogClock(event.canvas)"
      />
    </container>

    <!-- Digital time display -->
    <text id="digitalTime" style="font-weight: bold; font-size: large; text-align: center; color: white;">
      00:00:00
    </text>

    <!-- Control panel -->
    <container style="display: flex; flex-direction: row; justify-content: center; gap: 1;">
      <button
        id="startBtn"
        label="Start"
        style="background-color: green; color: white; padding: 1;"
        onClick="$app.toggleClock();"
      />

      <button
        label="Timezone"
        style="background-color: blue; color: white; padding: 1;"
        onClick="$app.cycleTimezone();"
      />

      <button
        label="Theme"
        style="background-color: purple; color: white; padding: 1;"
        onClick="$app.cycleTheme();"
      />

      <button
        id="secondsBtn"
        label="Hide Seconds"
        style="background-color: blue; color: white; padding: 1;"
        onClick="$app.toggleSeconds();"
      />
    </container>

    <!-- Settings panel -->
    <container style="display: flex; flex-direction: row; justify-content: center; gap: 1;">
      <button
        id="digitalBtn"
        label="Hide Digital"
        style="background-color: purple; color: white; padding: 1;"
        onClick="$app.toggleDigital();"
      />

      <button
        id="formatBtn"
        label="24 Hour"
        style="background-color: gray; color: white; padding: 1;"
        onClick="$app.toggle24Hour();"
      />

      <button
        id="rateBtn"
        label="Rate: 1000ms"
        style="background-color: orange; color: white; padding: 1;"
        onClick="$app.adjustRefreshRate();"
      />

      <button
        id="statsBtn"
        label="Show Stats"
        style="background-color: gray; color: white; padding: 1;"
        onClick="$app.toggleStatistics();"
      />

      <button
        label="Exit"
        style="background-color: red; color: white; padding: 1;"
        onClick="$melker.exit();"
      />
    </container>

    <!-- Statistics display (hidden by default) -->
    <text id="statistics" style="color: cyan; text-align: center; font-size: small; display: none;">
      Statistics will appear here
    </text>

    <!-- Footer -->
    <container style="border-top: thin; border-color: gray;">
      <text style="color: gray; text-align: center; font-size: small;">
        ðŸš€ Enterprise-grade terminal clock with timezone support, themes, and real-time statistics
      </text>
    </container>

  </container>

  <script type="typescript">
    /**
     * Enterprise Analog Clock Application
     * Version: 1.0.0
     * Features: Multi-timezone support, themes, settings, statistics, error handling
     */

    // Application state and configuration
    interface ClockConfig {
      timezone: string;
      theme: 'light' | 'dark' | 'blue' | 'green';
      showSeconds: boolean;
      showDigital: boolean;
      show24Hour: boolean;
      autoResize: boolean;
      refreshRate: number;
      showStatistics: boolean;
    }

    interface ClockStatistics {
      uptime: number;
      frameCount: number;
      lastUpdateTime: number;
      avgFrameTime: number;
      errorCount: number;
      memoryUsage?: string;
    }

    // Global state
    let clockConfig: ClockConfig = {
      timezone: 'UTC',
      theme: 'dark',
      showSeconds: true,
      showDigital: true,
      show24Hour: false,
      autoResize: true,
      refreshRate: 1000,
      showStatistics: false
    };

    let clockStats: ClockStatistics = {
      uptime: 0,
      frameCount: 0,
      lastUpdateTime: Date.now(),
      avgFrameTime: 0,
      errorCount: 0
    };

    let clockInterval: number | null = null;
    let startTime = Date.now();
    let canvas: any = null;
    let isRunning = false;

    // Theme configurations
    const themes = {
      light: { bg: 'white', fg: 'black', accent: 'blue', border: 'gray' },
      dark: { bg: 'black', fg: 'white', accent: 'cyan', border: 'gray' },
      blue: { bg: 'navy', fg: 'white', accent: 'lightblue', border: 'blue' },
      green: { bg: 'darkgreen', fg: 'white', accent: 'lightgreen', border: 'green' }
    };

    // Timezone data (subset for demo)
    const timezones = [
      { label: 'UTC', value: 'UTC', offset: 0 },
      { label: 'New York (EST)', value: 'America/New_York', offset: -5 },
      { label: 'Los Angeles (PST)', value: 'America/Los_Angeles', offset: -8 },
      { label: 'London (GMT)', value: 'Europe/London', offset: 0 },
      { label: 'Tokyo (JST)', value: 'Asia/Tokyo', offset: 9 },
      { label: 'Sydney (AEST)', value: 'Australia/Sydney', offset: 10 }
    ];

    // Error handling and logging
    function logError(error: string, context?: string): void {
      clockStats.errorCount++;
      console.error(`[Clock Error] ${context ? `[${context}] ` : ''}${error}`);
    }

    function safeExecute<T>(operation: () => T, fallback: T, context?: string): T {
      try {
        return operation();
      } catch (error) {
        logError(error instanceof Error ? error.message : String(error), context);
        return fallback;
      }
    }

    // Time utilities with timezone support
    function getCurrentTime(): Date {
      return safeExecute(() => {
        const now = new Date();
        if (clockConfig.timezone === 'UTC') return now;

        // Simple timezone offset calculation (for demo purposes)
        const tz = timezones.find(t => t.value === clockConfig.timezone);
        if (tz) {
          const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
          return new Date(utc + (tz.offset * 3600000));
        }
        return now;
      }, new Date(), 'getCurrentTime');
    }

    function formatDigitalTime(date: Date): string {
      return safeExecute(() => {
        let hours = date.getHours();
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const seconds = date.getSeconds().toString().padStart(2, '0');

        if (clockConfig.show24Hour) {
          return `${hours.toString().padStart(2, '0')}:${minutes}${clockConfig.showSeconds ? ':' + seconds : ''}`;
        } else {
          const ampm = hours >= 12 ? 'PM' : 'AM';
          hours = hours % 12;
          if (hours === 0) hours = 12;
          return `${hours}:${minutes}${clockConfig.showSeconds ? ':' + seconds : ''} ${ampm}`;
        }
      }, '00:00:00', 'formatDigitalTime');
    }

    // Enhanced clock drawing with themes and error handling
    // Uses aspect-ratio corrected methods for visually round circles
    export function drawAnalogClock(canvasArg?: any): void {
      const c = canvasArg || canvas;
      if (!c) return;

      safeExecute(() => {
        // Get layout bounds and resize canvas to fit
        const bounds = c.getBounds();
        if (bounds && (c.props.width !== bounds.width || c.props.height !== bounds.height)) {
          c.setSize(bounds.width, bounds.height);
        }

        const now = getCurrentTime();
        const theme = themes[clockConfig.theme];

        // Clear canvas
        c.clear();

        // Work in visual coordinates (equal units in both dimensions)
        const visSize = c.getVisualSize();
        const visCenterX = visSize.width / 2;
        const visCenterY = visSize.height / 2;
        const radius = Math.min(visCenterX, visCenterY) - 6;

        if (radius < 10) return; // Too small to draw

        // Convert visual center to pixel for drawCircleCorrected
        const [pxCenterX, pxCenterY] = c.visualToPixel(visCenterX, visCenterY);

        // Draw outer circle (aspect-ratio corrected for round appearance)
        c.drawCircleCorrected(pxCenterX, pxCenterY, radius);

        // Draw hour markers using visual coords
        for (let i = 0; i < 12; i++) {
          const angle = (i * Math.PI) / 6;
          const isMainHour = i % 3 === 0;
          const innerRadius = radius - (isMainHour ? 8 : 4);
          const outerRadius = radius - 2;

          const x1 = visCenterX + innerRadius * Math.cos(angle - Math.PI / 2);
          const y1 = visCenterY + innerRadius * Math.sin(angle - Math.PI / 2);
          const x2 = visCenterX + outerRadius * Math.cos(angle - Math.PI / 2);
          const y2 = visCenterY + outerRadius * Math.sin(angle - Math.PI / 2);

          c.drawLineCorrected(x1, y1, x2, y2);
        }

        // Calculate hand angles
        const hours = now.getHours() % 12;
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();

        const hourAngle = (hours + minutes / 60) * (Math.PI / 6);
        const minuteAngle = minutes * (Math.PI / 30);
        const secondAngle = seconds * (Math.PI / 30);

        // Draw hour hand
        const hourLength = radius * 0.5;
        const hourX = visCenterX + hourLength * Math.cos(hourAngle - Math.PI / 2);
        const hourY = visCenterY + hourLength * Math.sin(hourAngle - Math.PI / 2);
        c.drawLineCorrected(visCenterX, visCenterY, hourX, hourY);

        // Draw minute hand
        const minuteLength = radius * 0.7;
        const minuteX = visCenterX + minuteLength * Math.cos(minuteAngle - Math.PI / 2);
        const minuteY = visCenterY + minuteLength * Math.sin(minuteAngle - Math.PI / 2);
        c.drawLineCorrected(visCenterX, visCenterY, minuteX, minuteY);

        // Draw second hand (conditional)
        if (clockConfig.showSeconds) {
          const secondLength = radius * 0.8;
          const secondX = visCenterX + secondLength * Math.cos(secondAngle - Math.PI / 2);
          const secondY = visCenterY + secondLength * Math.sin(secondAngle - Math.PI / 2);
          c.drawLineCorrected(visCenterX, visCenterY, secondX, secondY);
        }

        // Draw center hub
        c.fillRect(pxCenterX - 1, pxCenterY - 1, 3, 3);

        // Update statistics
        clockStats.frameCount++;
        const currentTime = Date.now();
        const frameTime = currentTime - clockStats.lastUpdateTime;
        clockStats.avgFrameTime = (clockStats.avgFrameTime + frameTime) / 2;
        clockStats.lastUpdateTime = currentTime;
        clockStats.uptime = Math.floor((currentTime - startTime) / 1000);

      }, undefined, 'drawAnalogClock');
    }

    // UI update functions
    function updateDigitalDisplay(): void {
      const digitalElement = $melker.getElementById('digitalTime');
      if (digitalElement && clockConfig.showDigital) {
        const time = formatDigitalTime(getCurrentTime());
        digitalElement.setValue(time);
      }
    }

    function updateTimezoneDisplay(): void {
      const tzElement = $melker.getElementById('timezoneDisplay');
      if (tzElement) {
        const tz = timezones.find(t => t.value === clockConfig.timezone);
        const label = tz ? tz.label : clockConfig.timezone;
        tzElement.setValue(`Zone: ${label}`);
      }
    }

    function updateStatistics(): void {
      if (!clockConfig.showStatistics) return;

      const statsElement = $melker.getElementById('statistics');
      if (statsElement) {
        const stats = [
          `Uptime: ${Math.floor(clockStats.uptime / 60)}m ${clockStats.uptime % 60}s`,
          `Frames: ${clockStats.frameCount}`,
          `Avg Frame: ${clockStats.avgFrameTime.toFixed(1)}ms`,
          `Errors: ${clockStats.errorCount}`,
          `Rate: ${clockConfig.refreshRate}ms`
        ].join(' | ');

        statsElement.setValue(stats);
      }
    }

    // Clock control functions
    function startClock(): void {
      if (isRunning) return;

      isRunning = true;
      startTime = Date.now();
      clockStats = { ...clockStats, frameCount: 0, errorCount: 0 };

      clockInterval = setInterval(() => {
        try {
          drawAnalogClock();
          updateDigitalDisplay();
          updateTimezoneDisplay();
          updateStatistics();
          $melker.engine.render();
        } catch (error) {
          logError(error instanceof Error ? error.message : String(error), 'clockInterval');
        }
      }, clockConfig.refreshRate);

      // Update start button
      const startBtn = $melker.getElementById('startBtn');
      if (startBtn) {
        startBtn.props.label = 'Stop';
        startBtn.props.style = { ...startBtn.props.style, backgroundColor: 'red' };
      }
    }

    function stopClock(): void {
      if (!isRunning) return;

      isRunning = false;
      if (clockInterval) {
        clearInterval(clockInterval);
        clockInterval = null;
      }

      // Update start button
      const startBtn = $melker.getElementById('startBtn');
      if (startBtn) {
        startBtn.props.label = 'Start';
        startBtn.props.style = { ...startBtn.props.style, backgroundColor: 'green' };
      }
    }

    export function toggleClock(): void {
      if (isRunning) {
        stopClock();
      } else {
        startClock();
      }
      $melker.engine.render();
    }

    // Settings functions
    export function cycleTimezone(): void {
      const currentIndex = timezones.findIndex(t => t.value === clockConfig.timezone);
      const nextIndex = (currentIndex + 1) % timezones.length;
      clockConfig.timezone = timezones[nextIndex].value;
      updateTimezoneDisplay();
      $melker.engine.render();
    }

    export function cycleTheme(): void {
      const themes_list = Object.keys(themes) as Array<keyof typeof themes>;
      const currentIndex = themes_list.findIndex(t => t === clockConfig.theme);
      const nextIndex = (currentIndex + 1) % themes_list.length;
      clockConfig.theme = themes_list[nextIndex];

      // Update canvas style
      const canvasElement = $melker.getElementById('clockCanvas');
      if (canvasElement) {
        const theme = themes[clockConfig.theme];
        canvasElement.props.style = {
          ...canvasElement.props.style,
          backgroundColor: theme.bg,
          borderColor: theme.border
        };
      }
      // Redraw clock immediately if running to prevent blank canvas after style change
      if (isRunning) drawAnalogClock();
      $melker.engine.render();
    }

    export function toggleSeconds(): void {
      clockConfig.showSeconds = !clockConfig.showSeconds;
      const btn = $melker.getElementById('secondsBtn');
      if (btn) {
        btn.props.label = clockConfig.showSeconds ? 'Hide Seconds' : 'Show Seconds';
        btn.props.style = {
          ...btn.props.style,
          backgroundColor: clockConfig.showSeconds ? 'blue' : 'gray'
        };
      }
      $melker.engine.render();
    }

    export function toggleDigital(): void {
      clockConfig.showDigital = !clockConfig.showDigital;
      const digitalElement = $melker.getElementById('digitalTime');
      const btn = $melker.getElementById('digitalBtn');

      if (digitalElement) {
        digitalElement.props.style = {
          ...digitalElement.props.style,
          display: clockConfig.showDigital ? 'block' : 'none'
        };
      }

      if (btn) {
        btn.props.label = clockConfig.showDigital ? 'Hide Digital' : 'Show Digital';
        btn.props.style = {
          ...btn.props.style,
          backgroundColor: clockConfig.showDigital ? 'purple' : 'gray'
        };
      }
      $melker.engine.render();
    }

    export function toggle24Hour(): void {
      clockConfig.show24Hour = !clockConfig.show24Hour;
      const btn = $melker.getElementById('formatBtn');
      if (btn) {
        btn.props.label = clockConfig.show24Hour ? '12 Hour' : '24 Hour';
        btn.props.style = {
          ...btn.props.style,
          backgroundColor: clockConfig.show24Hour ? 'orange' : 'gray'
        };
      }
      updateDigitalDisplay();
      $melker.engine.render();
    }

    export function toggleStatistics(): void {
      clockConfig.showStatistics = !clockConfig.showStatistics;
      const statsElement = $melker.getElementById('statistics');
      const btn = $melker.getElementById('statsBtn');

      if (statsElement) {
        statsElement.props.style = {
          ...statsElement.props.style,
          display: clockConfig.showStatistics ? 'block' : 'none'
        };
      }

      if (btn) {
        btn.props.label = clockConfig.showStatistics ? 'Hide Stats' : 'Show Stats';
        btn.props.style = {
          ...btn.props.style,
          backgroundColor: clockConfig.showStatistics ? 'teal' : 'gray'
        };
      }
      $melker.engine.render();
    }

    export function adjustRefreshRate(): void {
      const rates = [100, 250, 500, 1000, 2000];
      const currentIndex = rates.findIndex(r => r === clockConfig.refreshRate);
      const nextIndex = (currentIndex + 1) % rates.length;
      clockConfig.refreshRate = rates[nextIndex];

      // Restart clock with new rate if running
      if (isRunning) {
        stopClock();
        startClock();
      }

      const btn = $melker.getElementById('rateBtn');
      if (btn) {
        btn.props.label = `Rate: ${clockConfig.refreshRate}ms`;
      }
      $melker.engine.render();
    }

    // Auto-resize handler - canvas uses getBounds() so just trigger redraw
    $melker.engine.onResize(() => {
      if (!clockConfig.autoResize) return;
      if (isRunning) {
        drawAnalogClock();
        $melker.engine.render();
      }
    });

    // Cleanup on exit
    function cleanup(): void {
      stopClock();
      console.log('Enterprise Analog Clock stopped gracefully');
    }

    // Export cleanup for potential external use
    (globalThis as any).cleanupClock = cleanup;

    // Initialize application (called on ready)
    export function init(): void {
      try {
        canvas = $melker.getElementById('clockCanvas');
        if (canvas) {
          // Apply initial theme
          const theme = themes[clockConfig.theme];
          canvas.props.style = {
            ...canvas.props.style,
            backgroundColor: theme.bg,
            borderColor: theme.border
          };

          // Initial UI updates
          updateTimezoneDisplay();
          updateDigitalDisplay();

          // Initial clock draw (uses getBounds() for sizing)
          drawAnalogClock();

          $melker.engine.render();

          // Auto-start
          startClock();
        }
      } catch (error) {
        logError(error instanceof Error ? error.message : String(error), 'init');
      }
    }

  </script>

  <script type="typescript" async="ready">
    $app.init();
  </script>
</melker>
