<melker>
<policy>
{
  "name": "melker-htop",
  "description": "Cross-platform terminal system monitor inspired by htop",
  "permissions": {
    "all" : true
  },
  "comment": "Linux uses /proc filesystem, macOS uses sysctl/vm_stat/ps commands. Reading /proc  needs all permissions"
}
</policy>

<help>
Cross-platform data sources:

| Function    | Linux                       | macOS                            |
|-------------|-----------------------------|----------------------------------|
| CPU stats   | /proc/stat                  | sysctl hw.ncpu + vm.loadavg      |
| Memory      | /proc/meminfo               | sysctl hw.memsize + vm_stat      |
| Swap        | /proc/meminfo               | sysctl vm.swapusage              |
| Load/uptime | /proc/loadavg, /proc/uptime | sysctl vm.loadavg, kern.boottime |
| Processes   | /proc/<pid>/*               | ps -axo user=,pid=,...           |
</help>

<style>
.row { display: flex; flex-direction: row; }
.meters { display: flex; flex-direction: column; width: 50%; }
.info { display: flex; flex-direction: column; width: 50%; white-space: pre; }
.footer { display: flex; flex-direction: row; flex-shrink: 0; }
</style>

<container style="display: flex; flex-direction: column; height: 100%; padding: 1">
  <container class="row">
    <container class="meters">
      <container id="cpuMeters" style="display: flex; flex-direction: row; padding-bottom: 1"></container>
      <container id="memMeter"></container>
      <container id="swpMeter"></container>
    </container>
    <container class="info">
      <text id="info"></text>
    </container>
  </container>

  <data-table
    id="procTable"
    style="border: thin; flex: 1;"
    showColumnBorders="false"
    sortColumn="3"
    sortDirection="desc"
    selectable="single"
    onActivate="$app.showProcessDetails(event)"
  >
  {
    "columns": [
      { "header": "PID", "width": 12 },
      { "header": "USER", "width": "8%" },
      { "header": "S", "width": "3%" },
      { "header": "CPU%", "width": 8, "align": "right" },
      { "header": "MEM%", "width": "6%", "align": "right" },
      { "header": "RES", "width": "6%", "align": "right" },
      { "header": "TIME+", "width": "8%", "align": "right" },
      { "header": "Command" }
    ]
  }
  </data-table>

  <container class="footer">
    <checkbox id="treeChk" title="Tree" onChange="$app.setTreeView(event.checked)" style="padding-right: 1"/>
    <text> Ctrl+C:Quit  Scroll:Mouse  Click header:sort  Double-click:details</text>
  </container>

  <dialog id="processDialog" title="Process Details" style="width: 80; height: 18;" modal="true" backdrop="false" draggable="true" resizable="true">
    <container style="display: flex; flex-direction: column; height: 100%; width: fill">
      <container style="overflow: scroll; flex: 1 1 0; width: fill">
        <markdown id="dialogContent" style="text-wrap: wrap; width: fill"></markdown>
      </container>
      <container style="display: flex; flex-direction: row; justify-content: center; padding-top: 1; gap: 2">
        <button label="Kill" onClick="killProcess"></button>
        <button label="Close" onClick="closeDialog"></button>
      </container>
    </container>
  </dialog>
</container>

<script type="typescript">
// Type definitions
interface Process {
  pid: number;
  ppid: number;
  user: string;
  state: string;
  cpu: number;
  mem: number;
  vsz: number;
  rss: number;
  time: number;
  command: string;
  // Tree view fields (computed)
  depth?: number;
  treePrefix?: string;
}

interface CpuCore {
  id: number;
  percent: number;
}

interface CpuStats {
  cores: CpuCore[];
  total: number;
  totalTime: number;
}

interface MemStats {
  total: number;
  used: number;
  percent: number;
}

interface TaskCounts {
  total: number;
  running: number;
  sleeping: number;
}

interface CpuTime {
  total: number;
  busy: number;
}

interface State {
  processes: Process[];
  cpuStats: CpuStats;
  memStats: MemStats;
  swapStats: MemStats;
  loadAvg: [number, number, number];
  uptime: string;
  taskCounts: TaskCounts;
  refreshInterval: number | null;
  prevCpuTimes: CpuTime[];
  prevTotalCpuTime: number;
  prevProcCpuTimes: Record<number, number>;
  selectedProcess: Process | null;
  treeView: boolean;
}

interface RowActivateEvent {
  rowIndex: number;
  row: (string | number)[];
}

// Platform detection
const isMacOS = Deno.build.os === "darwin";
const isLinux = Deno.build.os === "linux";

// State record
const state: State = {
  processes: [],
  cpuStats: { cores: [], total: 0, totalTime: 0 },
  memStats: { total: 0, used: 0, percent: 0 },
  swapStats: { total: 0, used: 0, percent: 0 },
  loadAvg: [0, 0, 0],
  uptime: "",
  taskCounts: { total: 0, running: 0, sleeping: 0 },
  refreshInterval: null,
  prevCpuTimes: [],
  prevTotalCpuTime: 0,
  prevProcCpuTimes: {},
  selectedProcess: null,
  treeView: false,
};

// Parse /proc/stat for CPU usage (Linux)
async function getCpuStatsLinux(): Promise<CpuStats> {
  try {
    const stat = await Deno.readTextFile("/proc/stat");
    const lines = stat.split("\n");
    const cores: CpuCore[] = [];
    let totalCpuTime = 0;

    for (let j = 0; j < lines.length; j++) {
      const line = lines[j];
      // Get aggregate CPU time from "cpu " line (with space)
      if (line.startsWith("cpu ")) {
        const parts = line.split(/\s+/);
        const user = parseInt(parts[1]) || 0;
        const nice = parseInt(parts[2]) || 0;
        const system = parseInt(parts[3]) || 0;
        const idle = parseInt(parts[4]) || 0;
        const iowait = parseInt(parts[5]) || 0;
        const irq = parseInt(parts[6]) || 0;
        const softirq = parseInt(parts[7]) || 0;
        const steal = parseInt(parts[8]) || 0;
        totalCpuTime = user + nice + system + idle + iowait + irq + softirq + steal;
      }
      // Get per-core stats from "cpuN" lines
      if (line.startsWith("cpu") && line[3] !== " ") {
        const parts = line.split(/\s+/);
        const name = parts[0];
        const user = parseInt(parts[1]) || 0;
        const nice = parseInt(parts[2]) || 0;
        const system = parseInt(parts[3]) || 0;
        const idle = parseInt(parts[4]) || 0;
        const iowait = parseInt(parts[5]) || 0;
        const irq = parseInt(parts[6]) || 0;
        const softirq = parseInt(parts[7]) || 0;
        const steal = parseInt(parts[8]) || 0;

        const total = user + nice + system + idle + iowait + irq + softirq + steal;
        const busy = total - idle - iowait;

        const idx = parseInt(name.slice(3));
        const prev = state.prevCpuTimes[idx] || { total: 0, busy: 0 };

        const totalDelta = total - prev.total;
        const busyDelta = busy - prev.busy;
        const percent = totalDelta > 0 ? (busyDelta / totalDelta) * 100 : 0;

        state.prevCpuTimes[idx] = { total: total, busy: busy };
        cores.push({ id: idx, percent: Math.min(100, Math.max(0, percent)) });
      }
    }
    let avgPercent = 0;
    for (let k = 0; k < cores.length; k++) avgPercent += cores[k].percent;
    return { cores: cores, total: cores.length > 0 ? avgPercent / cores.length : 0, totalTime: totalCpuTime };
  } catch (e) {
    return { cores: [], total: 0, totalTime: 0 };
  }
}

// Get CPU stats using sysctl (macOS)
async function getCpuStatsMacOS(): Promise<CpuStats> {
  try {
    // Get number of CPUs
    const ncpuCmd = new Deno.Command("sysctl", { args: ["-n", "hw.ncpu"] });
    const ncpuResult = await ncpuCmd.output();
    const numCores = parseInt(new TextDecoder().decode(ncpuResult.stdout).trim()) || 1;

    // Get CPU load info - macOS doesn't give per-core easily, so we use overall
    const loadCmd = new Deno.Command("sysctl", { args: ["-n", "vm.loadavg"] });
    const loadResult = await loadCmd.output();
    const loadStr = new TextDecoder().decode(loadResult.stdout).trim();
    // Format: { 1.23 1.45 1.67 }
    const loadMatch = loadStr.match(/\{\s*([\d.]+)/);
    const load1 = loadMatch ? parseFloat(loadMatch[1]) : 0;

    // Estimate CPU usage from load average (rough approximation)
    // Load of 1.0 per core = 100% usage
    const overallPercent = Math.min(100, (load1 / numCores) * 100);

    // Create synthetic per-core stats (macOS sysctl doesn't easily expose per-core)
    const cores: CpuCore[] = [];
    for (let i = 0; i < numCores; i++) {
      cores.push({ id: i, percent: overallPercent });
    }

    return { cores: cores, total: overallPercent, totalTime: Date.now() };
  } catch (e) {
    return { cores: [], total: 0, totalTime: 0 };
  }
}

// Cross-platform CPU stats
async function getCpuStats(): Promise<CpuStats> {
  if (isMacOS) {
    return getCpuStatsMacOS();
  }
  return getCpuStatsLinux();
}

// Parse /proc/meminfo (Linux)
async function getMemStatsLinux(): Promise<{ mem: MemStats; swap: MemStats }> {
  try {
    const meminfo = await Deno.readTextFile("/proc/meminfo");
    const values: Record<string, number> = {};
    const lines = meminfo.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const match = lines[i].match(/^(\w+):\s+(\d+)/);
      if (match) values[match[1]] = parseInt(match[2]);
    }

    const total = values.MemTotal || 0;
    const free = values.MemFree || 0;
    const buffers = values.Buffers || 0;
    const cached = values.Cached || 0;
    const sReclaimable = values.SReclaimable || 0;
    const used = total - free - buffers - cached - sReclaimable;

    const swapTotal = values.SwapTotal || 0;
    const swapFree = values.SwapFree || 0;

    return {
      mem: { total: total * 1024, used: used * 1024, percent: total > 0 ? (used / total) * 100 : 0 },
      swap: { total: swapTotal * 1024, used: (swapTotal - swapFree) * 1024, percent: swapTotal > 0 ? ((swapTotal - swapFree) / swapTotal) * 100 : 0 }
    };
  } catch (e) {
    return { mem: { total: 0, used: 0, percent: 0 }, swap: { total: 0, used: 0, percent: 0 } };
  }
}

// Get memory stats using vm_stat and sysctl (macOS)
async function getMemStatsMacOS(): Promise<{ mem: MemStats; swap: MemStats }> {
  try {
    // Get total physical memory
    const memCmd = new Deno.Command("sysctl", { args: ["-n", "hw.memsize"] });
    const memResult = await memCmd.output();
    const totalMem = parseInt(new TextDecoder().decode(memResult.stdout).trim()) || 0;

    // Get vm_stat output for memory usage
    const vmCmd = new Deno.Command("vm_stat", {});
    const vmResult = await vmCmd.output();
    const vmOutput = new TextDecoder().decode(vmResult.stdout);

    // Parse vm_stat output
    // Format: "Pages free:    123456."
    const pageSize = 16384; // macOS default page size (can vary, but 16KB is common on Apple Silicon)
    let pagesFree = 0;
    let pagesActive = 0;
    let pagesInactive = 0;
    let pagesWired = 0;
    let pagesCompressed = 0;

    const lines = vmOutput.split("\n");
    for (const line of lines) {
      const match = line.match(/^(.+?):\s+(\d+)/);
      if (match) {
        const key = match[1].trim();
        const value = parseInt(match[2]);
        if (key === "Pages free") pagesFree = value;
        else if (key === "Pages active") pagesActive = value;
        else if (key === "Pages inactive") pagesInactive = value;
        else if (key === "Pages wired down") pagesWired = value;
        else if (key === "Pages occupied by compressor") pagesCompressed = value;
      }
    }

    // Calculate used memory (active + wired + compressed)
    const usedPages = pagesActive + pagesWired + pagesCompressed;
    const usedMem = usedPages * pageSize;
    const memPercent = totalMem > 0 ? (usedMem / totalMem) * 100 : 0;

    // Get swap usage
    const swapCmd = new Deno.Command("sysctl", { args: ["-n", "vm.swapusage"] });
    const swapResult = await swapCmd.output();
    const swapOutput = new TextDecoder().decode(swapResult.stdout).trim();
    // Format: "total = 2048.00M  used = 512.00M  free = 1536.00M  (encrypted)"
    let swapTotal = 0;
    let swapUsed = 0;

    const totalMatch = swapOutput.match(/total\s*=\s*([\d.]+)([MG])/);
    const usedMatch = swapOutput.match(/used\s*=\s*([\d.]+)([MG])/);
    if (totalMatch) {
      swapTotal = parseFloat(totalMatch[1]) * (totalMatch[2] === "G" ? 1073741824 : 1048576);
    }
    if (usedMatch) {
      swapUsed = parseFloat(usedMatch[1]) * (usedMatch[2] === "G" ? 1073741824 : 1048576);
    }

    return {
      mem: { total: totalMem, used: usedMem, percent: memPercent },
      swap: { total: swapTotal, used: swapUsed, percent: swapTotal > 0 ? (swapUsed / swapTotal) * 100 : 0 }
    };
  } catch (e) {
    return { mem: { total: 0, used: 0, percent: 0 }, swap: { total: 0, used: 0, percent: 0 } };
  }
}

// Cross-platform memory stats
async function getMemStats(): Promise<{ mem: MemStats; swap: MemStats }> {
  if (isMacOS) {
    return getMemStatsMacOS();
  }
  return getMemStatsLinux();
}

// Parse /proc/loadavg and uptime (Linux)
async function getSystemInfoLinux(): Promise<{ load: [number, number, number]; uptime: string }> {
  try {
    const loadContent = await Deno.readTextFile("/proc/loadavg");
    const uptimeContent = await Deno.readTextFile("/proc/uptime");
    const parts = loadContent.split(/\s+/);
    const seconds = parseFloat(uptimeContent.split(/\s+/)[0]);
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    let uptimeStr = mins + "m";
    if (hours > 0) uptimeStr = hours + "h " + uptimeStr;
    if (days > 0) uptimeStr = days + "d " + uptimeStr;
    return {
      load: [parseFloat(parts[0]), parseFloat(parts[1]), parseFloat(parts[2])],
      uptime: uptimeStr
    };
  } catch (e) {
    return { load: [0, 0, 0], uptime: "?" };
  }
}

// Get system info using sysctl (macOS)
async function getSystemInfoMacOS(): Promise<{ load: [number, number, number]; uptime: string }> {
  try {
    // Get load average
    const loadCmd = new Deno.Command("sysctl", { args: ["-n", "vm.loadavg"] });
    const loadResult = await loadCmd.output();
    const loadStr = new TextDecoder().decode(loadResult.stdout).trim();
    // Format: { 1.23 1.45 1.67 }
    const loadMatch = loadStr.match(/\{\s*([\d.]+)\s+([\d.]+)\s+([\d.]+)/);
    const load: [number, number, number] = loadMatch
      ? [parseFloat(loadMatch[1]), parseFloat(loadMatch[2]), parseFloat(loadMatch[3])]
      : [0, 0, 0];

    // Get boot time and calculate uptime
    const bootCmd = new Deno.Command("sysctl", { args: ["-n", "kern.boottime"] });
    const bootResult = await bootCmd.output();
    const bootStr = new TextDecoder().decode(bootResult.stdout).trim();
    // Format: { sec = 1234567890, usec = 123456 } ...
    const bootMatch = bootStr.match(/sec\s*=\s*(\d+)/);
    let uptimeStr = "?";
    if (bootMatch) {
      const bootTime = parseInt(bootMatch[1]);
      const now = Math.floor(Date.now() / 1000);
      const seconds = now - bootTime;
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      uptimeStr = mins + "m";
      if (hours > 0) uptimeStr = hours + "h " + uptimeStr;
      if (days > 0) uptimeStr = days + "d " + uptimeStr;
    }

    return { load: load, uptime: uptimeStr };
  } catch (e) {
    return { load: [0, 0, 0], uptime: "?" };
  }
}

// Cross-platform system info
async function getSystemInfo(): Promise<{ load: [number, number, number]; uptime: string }> {
  if (isMacOS) {
    return getSystemInfoMacOS();
  }
  return getSystemInfoLinux();
}

// Get processes from /proc (Linux)
async function getProcessesLinux(): Promise<Process[]> {
  const procs: Process[] = [];
  let running = 0, sleeping = 0;
  const totalCpuDelta = state.cpuStats.totalTime - state.prevTotalCpuTime;
  const newProcCpuTimes: Record<number, number> = {};

  try {
    for await (const entry of Deno.readDir("/proc")) {
      if (!entry.isDirectory || !/^\d+$/.test(entry.name)) continue;
      const pid = parseInt(entry.name);
      try {
        const stat = await Deno.readTextFile("/proc/" + pid + "/stat");
        const status = await Deno.readTextFile("/proc/" + pid + "/status");

        const statMatch = stat.match(/^\d+\s+\((.+)\)\s+(\w)/);
        if (!statMatch) continue;

        const comm = statMatch[1];
        const procState = statMatch[2];
        const statParts = stat.split(")")[1].trim().split(/\s+/);
        // statParts[0] = state, [1] = ppid, ..., [11] = utime, [12] = stime
        const ppid = parseInt(statParts[1]) || 0;
        const utime = parseInt(statParts[11]) || 0;
        const stime = parseInt(statParts[12]) || 0;
        const procTime = utime + stime;

        // Calculate CPU% from delta
        let cpuPercent = 0;
        const prevProcTime = state.prevProcCpuTimes[pid];
        if (prevProcTime !== undefined && totalCpuDelta > 0) {
          const procDelta = procTime - prevProcTime;
          cpuPercent = (procDelta / totalCpuDelta) * 100;
        }
        newProcCpuTimes[pid] = procTime;

        let uid = "?", vmRss = 0, vmSize = 0;
        const statusLines = status.split("\n");
        for (let i = 0; i < statusLines.length; i++) {
          const line = statusLines[i];
          if (line.startsWith("Uid:")) uid = line.split(/\s+/)[1];
          else if (line.startsWith("VmRSS:")) vmRss = parseInt(line.split(/\s+/)[1]) * 1024;
          else if (line.startsWith("VmSize:")) vmSize = parseInt(line.split(/\s+/)[1]) * 1024;
        }

        let cmdline = comm;
        try {
          const cmd = await Deno.readTextFile("/proc/" + pid + "/cmdline");
          if (cmd.length > 0) cmdline = cmd.replace(/\0/g, " ").trim() || comm;
        } catch (e) {}

        if (procState === "R") running++; else sleeping++;

        procs.push({
          pid: pid,
          ppid: ppid,
          user: uid.substring(0, 8),
          state: procState,
          cpu: Math.min(100, Math.max(0, cpuPercent)),
          mem: state.memStats.total > 0 ? (vmRss / state.memStats.total) * 100 : 0,
          vsz: vmSize,
          rss: vmRss,
          time: procTime,
          command: cmdline.substring(0, 60)
        });
      } catch (e) {}
    }
  } catch (e) {}

  // Update previous values for next iteration
  state.prevProcCpuTimes = newProcCpuTimes;
  state.prevTotalCpuTime = state.cpuStats.totalTime;
  state.taskCounts = { total: procs.length, running: running, sleeping: sleeping };
  return procs;
}

// Get processes using ps (macOS)
async function getProcessesMacOS(): Promise<Process[]> {
  const procs: Process[] = [];
  let running = 0, sleeping = 0;

  try {
    // Use ps with specific format for predictable parsing
    // USER PID PPID %CPU %MEM VSZ RSS STAT TIME COMMAND
    const cmd = new Deno.Command("ps", {
      args: ["-axo", "user=,pid=,ppid=,pcpu=,pmem=,vsz=,rss=,state=,time=,comm="]
    });
    const result = await cmd.output();
    const output = new TextDecoder().decode(result.stdout);
    const lines = output.trim().split("\n");

    for (const line of lines) {
      // Parse fixed-width columns
      const parts = line.trim().split(/\s+/);
      if (parts.length < 10) continue;

      const user = parts[0];
      const pid = parseInt(parts[1]);
      const ppid = parseInt(parts[2]) || 0;
      const cpu = parseFloat(parts[3]) || 0;
      const mem = parseFloat(parts[4]) || 0;
      const vsz = (parseInt(parts[5]) || 0) * 1024; // VSZ is in KB
      const rss = (parseInt(parts[6]) || 0) * 1024; // RSS is in KB
      const procState = parts[7].charAt(0); // First char of state
      const timeStr = parts[8];
      const command = parts.slice(9).join(" ");

      if (isNaN(pid)) continue;

      // Parse time string (format: HH:MM:SS or M:SS or H:MM:SS.ss)
      let timeJiffies = 0;
      const timeParts = timeStr.split(":");
      if (timeParts.length === 3) {
        timeJiffies = (parseInt(timeParts[0]) * 3600 + parseInt(timeParts[1]) * 60 + parseFloat(timeParts[2])) * 100;
      } else if (timeParts.length === 2) {
        timeJiffies = (parseInt(timeParts[0]) * 60 + parseFloat(timeParts[1])) * 100;
      }

      // Map macOS states to Linux-like states
      // R=running, S=sleeping, U=uninterruptible, I=idle, T=stopped, Z=zombie
      const stateMap: Record<string, string> = { "R": "R", "S": "S", "U": "D", "I": "I", "T": "T", "Z": "Z" };
      const mappedState = stateMap[procState] || "S";

      if (mappedState === "R") running++; else sleeping++;

      procs.push({
        pid: pid,
        ppid: ppid,
        user: user.substring(0, 8),
        state: mappedState,
        cpu: Math.min(100, Math.max(0, cpu)),
        mem: mem,
        vsz: vsz,
        rss: rss,
        time: timeJiffies,
        command: command.substring(0, 60)
      });
    }
  } catch (e) {}

  state.taskCounts = { total: procs.length, running: running, sleeping: sleeping };
  return procs;
}

// Cross-platform process list
async function getProcesses(): Promise<Process[]> {
  if (isMacOS) {
    return getProcessesMacOS();
  }
  return getProcessesLinux();
}

// Build process tree and return processes in tree order with depth/prefix
function buildProcessTree(processes: Process[]): Process[] {
  // Build PID lookup and children map
  const pidSet = new Set<number>();
  const childrenMap = new Map<number, Process[]>();

  for (const proc of processes) {
    pidSet.add(proc.pid);
  }

  for (const proc of processes) {
    const parent = proc.ppid;
    if (!childrenMap.has(parent)) {
      childrenMap.set(parent, []);
    }
    childrenMap.get(parent)!.push(proc);
  }

  // Find root processes (ppid=0 or ppid not in our process list)
  const roots: Process[] = [];
  for (const proc of processes) {
    if (proc.ppid === 0 || !pidSet.has(proc.ppid)) {
      roots.push(proc);
    }
  }

  // Sort roots by PID for consistent ordering
  roots.sort((a, b) => a.pid - b.pid);

  // DFS traversal to build tree-ordered list
  const result: Process[] = [];

  function traverse(proc: Process, depth: number, prefix: string, isLast: boolean): void {
    // Clone process and add tree info
    const treeProc = { ...proc };
    treeProc.depth = depth;

    if (depth === 0) {
      treeProc.treePrefix = "";
    } else {
      treeProc.treePrefix = prefix + (isLast ? "└─" : "├─");
    }

    result.push(treeProc);

    // Get and sort children
    const children = childrenMap.get(proc.pid) || [];
    children.sort((a, b) => a.pid - b.pid);

    // Calculate prefix for children
    const childPrefix = depth === 0 ? "" : prefix + (isLast ? "  " : "│ ");

    for (let i = 0; i < children.length; i++) {
      traverse(children[i], depth + 1, childPrefix, i === children.length - 1);
    }
  }

  for (let i = 0; i < roots.length; i++) {
    traverse(roots[i], 0, "", i === roots.length - 1);
  }

  return result;
}

// Set tree view state
export function setTreeView(enabled: boolean): void {
  state.treeView = enabled;
  // When enabling tree view, clear sorting so tree order is preserved
  if (enabled) {
    const procTable = $melker.getElementById("procTable");
    if (procTable) {
      procTable.props.sortColumn = undefined;
      procTable.props.sortDirection = undefined;
    }
  }
  updateUI();
  $melker.render();
}

// Format bytes
function fmtB(bytes: number): string {
  if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(1) + "G";
  if (bytes >= 1048576) return (bytes / 1048576).toFixed(0) + "M";
  if (bytes >= 1024) return (bytes / 1024).toFixed(0) + "K";
  return bytes + "B";
}

// Format time
function fmtT(jiffies: number): string {
  const s = Math.floor(jiffies / 100);
  const m = Math.floor(s / 60);
  const h = Math.floor(m / 60);
  if (h > 0) return h + ":" + (m % 60).toString().padStart(2, "0") + ":" + (s % 60).toString().padStart(2, "0");
  return m + ":" + (s % 60).toString().padStart(2, "0");
}

// Close the process details dialog
export function closeDialog(): void {
  const dialog = $melker.getElementById("processDialog");
  if (dialog) {
    dialog.props.open = false;
  }
}

// Kill the selected process
export async function killProcess(): Promise<void> {
  if (!state.selectedProcess) return;

  try {
    const cmd = new Deno.Command("kill", { args: [state.selectedProcess.pid.toString()] });
    const result = await cmd.output();
    if (result.success) {
      $melker.getElementById("processDialog").props.open = false;
      await refresh();
      $melker.render();
    } else {
      $melker.alert("Failed to kill process " + state.selectedProcess.pid);
    }
  } catch (e) {
    $melker.alert("Error killing process: " + e.message);
  }
}

// Handle row double-click - show process details dialog
export function showProcessDetails(event: RowActivateEvent): void {
  // Look up process by PID from row data (first column)
  const pid = typeof event.row[0] === 'number' ? event.row[0] : parseInt(String(event.row[0]));
  state.selectedProcess = state.processes.find(p => p.pid === pid) || null;
  if (state.selectedProcess) {
    const dialog = $melker.getElementById("processDialog");
    if (dialog) {
      // Update dialog content
      const content = $melker.getElementById("dialogContent");
      if (content) {
        const stateNames = { R: "Running", S: "Sleeping", D: "Disk Sleep", Z: "Zombie", T: "Stopped", I: "Idle" };
        const stateName = stateNames[state.selectedProcess.state] || state.selectedProcess.state;
        content.setValue(
          "| Property | Value |\n" +
          "|----------|-------|\n" +
          "| **PID** | " + state.selectedProcess.pid + " |\n" +
          "| **PPID** | " + state.selectedProcess.ppid + " |\n" +
          "| **User** | " + state.selectedProcess.user + " |\n" +
          "| **State** | " + stateName + " |\n" +
          "| **CPU** | " + state.selectedProcess.cpu.toFixed(1) + "% |\n" +
          "| **Memory** | " + state.selectedProcess.mem.toFixed(1) + "% |\n" +
          "| **RSS** | " + fmtB(state.selectedProcess.rss) + " |\n" +
          "| **VSZ** | " + fmtB(state.selectedProcess.vsz) + " |\n" +
          "| **Time** | " + fmtT(state.selectedProcess.time) + " |\n" +
          "| **Command** | " + state.selectedProcess.command + " |");
      }
      dialog.props.open = true;
    }
  }
}

// CPU gradient:  (using OKLCH for perceptually uniform transitions)
const cpuGradient = [
  { stop: 0, color: "#008800" },
  { stop: 1, color: "#ffffff" }
];

// Memory gradient:  (using OKLCH)
const memGradient = [
  { stop: 0, color: "#000077" },
  { stop: 1, color: "#ffffff" }
];

// Update UI
function updateUI(): void {
  const barWidth = 15;
  const maxPerColumn = 6;

  // CPU meters - dynamically create progress components in columns
  const cpuContainer = $melker.getElementById("cpuMeters");
  if (cpuContainer) {
    cpuContainer.children = [];

    const numCores = state.cpuStats.cores.length;
    const numColumns = Math.ceil(numCores / maxPerColumn);

    for (let col = 0; col < numColumns; col++) {
      // Create column container
      const column = $melker.createElement("container", { style: { display: "flex", flexDirection: "column", marginRight: 1 } });

      for (let row = 0; row < maxPerColumn; row++) {
        const i = col * maxPerColumn + row;
        if (i >= numCores) break;

        const core = state.cpuStats.cores[i];
        // Create row container for label + progress + percentage
        const rowEl = $melker.createElement("container", { style: { display: "flex", flexDirection: "row", alignItems: "center" } });

        // CPU label
        const label = $melker.createElement("text", { text: i.toString().padStart(2) + " ", style: { width: 3 } });
        rowEl.children.push(label);

        // Progress bar with gradient (oklch for smooth color transitions)
        const progress = $melker.createElement("progress", {
          value: core.percent,
          max: 100,
          width: barWidth,
          height: 1,
          gradient: cpuGradient,
          colorSpace: "oklch",
          emptyColor: "transparent"
        });
        rowEl.children.push(progress);

        // Percentage text
        const pct = $melker.createElement("text", { text: core.percent.toFixed(0).padStart(3) + "%" });
        rowEl.children.push(pct);

        column.children.push(rowEl);
      }
      cpuContainer.children.push(column);
    }
  }

  // Memory bar with gradient (oklch)
  const memContainer = $melker.getElementById("memMeter");
  if (memContainer) {
    memContainer.children = [];
    const memRow = $melker.createElement("container", { style: { display: "flex", flexDirection: "row", alignItems: "center" } });
    memRow.children.push($melker.createElement("text", { text: "Mem", style: { width: 3 } }));
    memRow.children.push($melker.createElement("progress", { value: state.memStats.percent, max: 100, width: barWidth, height: 1, gradient: memGradient, colorSpace: "oklch", emptyColor: "transparent" }));
    memRow.children.push($melker.createElement("text", { text: " " + fmtB(state.memStats.used).padStart(6) + "/" + fmtB(state.memStats.total) }));
    memContainer.children.push(memRow);
  }

  // Swap bar with gradient (oklch)
  const swpContainer = $melker.getElementById("swpMeter");
  if (swpContainer) {
    swpContainer.children = [];
    const swpRow = $melker.createElement("container", { style: { display: "flex", flexDirection: "row", alignItems: "center" } });
    swpRow.children.push($melker.createElement("text", { text: "Swp", style: { width: 3 } }));
    swpRow.children.push($melker.createElement("progress", { value: state.swapStats.percent, max: 100, width: barWidth, height: 1, gradient: memGradient, colorSpace: "oklch", emptyColor: "transparent" }));
    swpRow.children.push($melker.createElement("text", { text: " " + fmtB(state.swapStats.used).padStart(6) + "/" + fmtB(state.swapStats.total) }));
    swpContainer.children.push(swpRow);
  }

  // Info
  const infoEl = $melker.getElementById("info");
  if (infoEl) {
    const loadStr = state.loadAvg[0].toFixed(2) + " " + state.loadAvg[1].toFixed(2) + " " + state.loadAvg[2].toFixed(2);
    infoEl.setValue("Tasks: " + state.taskCounts.total + ", " + state.taskCounts.running + " running\nLoad: " + loadStr + "\nUptime: " + state.uptime);
  }

  // Process table - update rows data
  const procTable = $melker.getElementById("procTable");
  if (procTable) {
    // Apply tree view if enabled
    const displayProcs = state.treeView ? buildProcessTree(state.processes) : state.processes;

    procTable.setValue(displayProcs.map(function(proc) {
      // Prepend tree prefix to command when in tree view
      const commandDisplay = state.treeView && proc.treePrefix
        ? proc.treePrefix + proc.command
        : proc.command;

      return [
        proc.pid,
        proc.user,
        proc.state,
        proc.cpu.toFixed(1),
        proc.mem.toFixed(1),
        fmtB(proc.rss),
        fmtT(proc.time),
        commandDisplay
      ];
    }));
  }

  // Sync tree checkbox state
  const treeChk = $melker.getElementById("treeChk");
  if (treeChk) {
    treeChk.props.checked = state.treeView;
  }
}

// Refresh all stats
async function refresh(): Promise<void> {
  state.cpuStats = await getCpuStats();
  const mem = await getMemStats();
  state.memStats = mem.mem;
  state.swapStats = mem.swap;
  const sys = await getSystemInfo();
  state.loadAvg = sys.load;
  state.uptime = sys.uptime;
  state.processes = await getProcesses();
  updateUI();
}

// Initialize app (called on ready)
export async function init() {
  await refresh();
  $melker.engine.render();

  state.refreshInterval = setInterval(async function() {
    await refresh();
    $melker.engine.render();
  }, 2000);
}
</script>

<script type="typescript" async="ready">
  await $app.init();
</script>
</melker>
