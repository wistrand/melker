#!/usr/bin/env -S deno run --allow-read --allow-write
// Generate bash and zsh completion scripts from config schema + hardcoded flags

import schema from '../src/config/schema.json' with { type: 'json' };

interface FlagDef {
  flag: string;
  type: 'boolean' | 'string' | 'integer' | 'number' | 'array';
  enum?: string[];
  description: string;
}

// --- Collect all flags ---

const flags: FlagDef[] = [];

// 1. Schema-driven flags
for (const [, prop] of Object.entries((schema as any).properties)) {
  const p = prop as any;
  if (!p.flag) continue;
  flags.push({
    flag: p.flag,
    type: p.type,
    enum: p.enum,
    description: p.description || '',
  });
}

// 2. Launcher-only flags (not in schema)
const launcherFlags: FlagDef[] = [
  { flag: '--help', type: 'boolean', description: 'Show help message' },
  { flag: '-h', type: 'boolean', description: 'Show help message' },
  { flag: '--trust', type: 'boolean', description: 'Run with full permissions' },
  { flag: '--test-sextant', type: 'boolean', description: 'Print sextant test pattern and exit' },
  { flag: '--print-config', type: 'boolean', description: 'Print current config and exit' },
  { flag: '--show-policy', type: 'boolean', description: 'Display app policy and exit' },
  { flag: '--clear-approvals', type: 'boolean', description: 'Clear all cached approvals' },
  { flag: '--revoke-approval', type: 'string', description: 'Revoke cached approval for path' },
  { flag: '--show-approval', type: 'string', description: 'Show cached approval for path' },
  { flag: '--schema', type: 'boolean', description: 'Output component schema and exit' },
  { flag: '--lsp', type: 'boolean', description: 'Start Language Server Protocol server' },
];
flags.push(...launcherFlags);

// 3. Runner-only flags (not in schema)
const runnerFlags: FlagDef[] = [
  { flag: '--print-tree', type: 'boolean', description: 'Display element tree and exit' },
  { flag: '--print-json', type: 'boolean', description: 'Display JSON serialization and exit' },
  { flag: '--verbose', type: 'boolean', description: 'Verbose output' },
  { flag: '--convert', type: 'boolean', description: 'Convert markdown to .melker (stdout)' },
  { flag: '--no-load', type: 'boolean', description: 'Skip loading persisted state' },
  { flag: '--cache', type: 'boolean', description: 'Use bundle cache' },
  { flag: '--watch', type: 'boolean', description: 'Watch file for changes and auto-reload' },
];
flags.push(...runnerFlags);

// 4. Forwarded Deno flags
const denoFlags: FlagDef[] = [
  { flag: '--reload', type: 'boolean', description: 'Reload remote modules' },
  { flag: '--no-lock', type: 'boolean', description: 'Disable lockfile' },
  { flag: '--no-check', type: 'boolean', description: 'Skip type checking' },
  { flag: '--quiet', type: 'boolean', description: 'Suppress diagnostic output' },
  { flag: '-q', type: 'boolean', description: 'Suppress diagnostic output' },
  { flag: '--cached-only', type: 'boolean', description: 'Require cached remote deps' },
  { flag: '--inspect', type: 'boolean', description: 'Enable V8 inspector' },
  { flag: '--inspect-wait', type: 'boolean', description: 'V8 inspector, wait for connection' },
  { flag: '--inspect-brk', type: 'boolean', description: 'V8 inspector, break at start' },
];
flags.push(...denoFlags);

// Sort flags (long flags only, skip short aliases for sorting)
flags.sort((a, b) => a.flag.localeCompare(b.flag));

// --- Generate bash completions ---

function generateBash(): string {
  const allFlagNames = flags.map(f => f.flag).join(' ');

  // Build case entries for enum flags
  const enumCases: string[] = [];
  for (const f of flags) {
    if (f.enum && f.enum.length > 0) {
      enumCases.push(`        ${f.flag})`);
      enumCases.push(`            COMPREPLY=( $(compgen -W "${f.enum.join(' ')}" -- "$cur") )`);
      enumCases.push(`            return 0`);
      enumCases.push(`            ;;`);
    }
  }

  // Build case entries for value-taking non-enum flags (file completions for paths)
  const valueCases: string[] = [];
  for (const f of flags) {
    if (f.type !== 'boolean' && !f.enum) {
      valueCases.push(`        ${f.flag})`);
      valueCases.push(`            return 0`);
      valueCases.push(`            ;;`);
    }
  }

  return `# Bash completion for melker
# Generated by scripts/generate-completions.ts — do not edit manually
#
# Usage: source completions/melker.bash
# Or copy to /etc/bash_completion.d/melker

_melker() {
    local cur prev
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"

    # Complete flag values
    case "$prev" in
${enumCases.join('\n')}
${valueCases.join('\n')}
    esac

    # Complete flags
    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $(compgen -W "${allFlagNames}" -- "$cur") )
        return 0
    fi

    # Complete .melker, .mmd, .md files
    COMPREPLY=( $(compgen -f -X '!*.@(melker|mmd|md)' -- "$cur") )
    # Also complete directories for navigation
    COMPREPLY+=( $(compgen -d -- "$cur") )
    return 0
}

complete -o default -o filenames -F _melker melker melker.ts
`;
}

// --- Generate zsh completions ---

function generateZsh(): string {
  const args: string[] = [];

  for (const f of flags) {
    const desc = f.description.replace(/'/g, "'\\''");
    if (f.type === 'boolean') {
      args.push(`        '${f.flag}[${desc}]'`);
    } else if (f.enum) {
      const values = f.enum.join(' ');
      args.push(`        '${f.flag}[${desc}]:value:(${values})'`);
    } else {
      args.push(`        '${f.flag}[${desc}]:value:'`);
    }
  }

  return `#compdef melker melker.ts
# Zsh completion for melker
# Generated by scripts/generate-completions.ts — do not edit manually
#
# Usage: Place in your $fpath (e.g. ~/.zsh/completions/_melker)
# Or source directly: source completions/melker.zsh

_melker() {
    _arguments -s \\
${args.join(' \\\n')} \\
        '*:file:_files -g "*.melker *.mmd *.md"'
}

_melker "$@"
`;
}

// --- Write output ---

const scriptDir = new URL('.', import.meta.url).pathname;
const projectDir = scriptDir.replace(/scripts\/$/, '');
const outDir = `${projectDir}completions`;

await Deno.mkdir(outDir, { recursive: true });

const bashContent = generateBash();
const zshContent = generateZsh();

await Deno.writeTextFile(`${outDir}/melker.bash`, bashContent);
await Deno.writeTextFile(`${outDir}/melker.zsh`, zshContent);

console.log(`Generated completions/${bashContent.split('\n').length} lines bash, ${zshContent.split('\n').length} lines zsh`);
console.log(`  completions/melker.bash`);
console.log(`  completions/melker.zsh`);
