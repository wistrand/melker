// Embedded asset system — bytes stored as grayscale PNG (base64), decoded synchronously.
//
// Data lives in assets-data.ts (generated by scripts/generate-embedded-assets.ts).
// Assets are decoded lazily on first access via decodePng() and cached.
//
// When assets.dynamic is enabled (MELKER_DYNAMIC_ASSETS=true), assets are read
// from source files on disk instead — useful during development to avoid running
// deno task build:assets after every change. Falls back to embedded on failure.

import { decodePng } from './deps.ts';
import { ASSET_DATA, ASSET_PATHS } from './assets-data.ts';
import { MelkerConfig } from './config/mod.ts';
import { readFileSync } from './runtime/mod.ts';

const _cache = new Map<string, Uint8Array>();
const _baseUrl = new URL('.', import.meta.url);

/** Decode an embedded base64 PNG asset to its original bytes. */
function decodeEmbedded(id: string): Uint8Array {
  const b64 = ASSET_DATA[id];
  if (!b64) throw new Error(`Unknown embedded asset: ${id}`);
  const bin = atob(b64);
  const png = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) png[i] = bin.charCodeAt(i);
  return new Uint8Array(decodePng(png).data);
}

/** Try reading an asset from its source file on disk. Returns null on failure. */
function readLocal(id: string): Uint8Array | null {
  const rel = ASSET_PATHS[id];
  if (!rel) return null;
  try {
    const url = new URL(rel, _baseUrl);
    return readFileSync(url);
  } catch {
    return null;
  }
}

/** Get asset bytes. Decodes on first access, then cached. */
export function getAsset(id: string): Uint8Array {
  let data = _cache.get(id);
  if (data) return data;

  if (MelkerConfig.get().dynamicAssets) {
    data = readLocal(id) ?? decodeEmbedded(id);
  } else {
    data = decodeEmbedded(id);
  }

  _cache.set(id, data);
  return data;
}

/** Get asset as text string. */
export function getAssetText(id: string): string {
  return new TextDecoder().decode(getAsset(id));
}

/** List all asset IDs, optionally filtered by prefix. */
export function getAssetIds(prefix?: string): string[] {
  const ids = Object.keys(ASSET_DATA);
  return prefix ? ids.filter((id) => id.startsWith(prefix)) : ids;
}
