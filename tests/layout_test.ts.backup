// Tests for the Advanced Layout Engine and Grid Layout Support

import { assertEquals, assertNotEquals, assert } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import {
  LayoutEngine,
  AdvancedLayoutNode as LayoutNode,
  LayoutContext,
  AdvancedLayoutProps,
  GridTrack,
  globalLayoutEngine,
  ContainerElement,
  TextElement,
  Element,
  Bounds,
  Size,
} from '../melker.ts';

Deno.test('LayoutEngine creation', () => {
  const engine = new LayoutEngine();
  assert(engine);
});

Deno.test('Basic block layout calculation', () => {
  const engine = new LayoutEngine();

  const child1 = new TextElement({ text: 'First', height: 2 });
  const child2 = new TextElement({ text: 'Second', height: 3 });
  const container = new ContainerElement({
    width: 20,
    height: 10,
    style: { display: 'block' }
  }, [child1, child2]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 20, height: 10 },
    parentBounds: { x: 0, y: 0, width: 20, height: 10 },
    availableSpace: { width: 20, height: 10 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 2);
  assertEquals(layoutTree.children[0].bounds.y, 0);
  assertEquals(layoutTree.children[1].bounds.y, layoutTree.children[0].bounds.height);
});

Deno.test('Flexbox row layout', () => {
  const engine = new LayoutEngine();

  const child1 = new TextElement({ text: 'A', flexGrow: 1 });
  const child2 = new TextElement({ text: 'B', flexGrow: 2 });
  const child3 = new TextElement({ text: 'C', flexGrow: 1 });

  const container = new ContainerElement({
    width: 20,
    height: 5,
    style: {
      display: 'flex',
      flexDirection: 'row'
    }
  }, [child1, child2, child3]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 20, height: 5 },
    parentBounds: { x: 0, y: 0, width: 20, height: 5 },
    availableSpace: { width: 20, height: 5 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 3);

  // Check horizontal positioning
  assertEquals(layoutTree.children[0].bounds.x, 0);
  assert(layoutTree.children[1].bounds.x > layoutTree.children[0].bounds.x);
  assert(layoutTree.children[2].bounds.x > layoutTree.children[1].bounds.x);

  // Check flex growth - child2 should be twice as wide as child1/child3
  const width1 = layoutTree.children[0].bounds.width;
  const width2 = layoutTree.children[1].bounds.width;
  const width3 = layoutTree.children[2].bounds.width;

  assert(Math.abs(width2 - (width1 * 2)) < 2); // Allow small rounding differences
  assert(Math.abs(width1 - width3) < 1);
});

Deno.test('Flexbox column layout', () => {
  const engine = new LayoutEngine();

  const child1 = new TextElement({ text: 'Top' });
  const child2 = new TextElement({ text: 'Bottom' });

  const container = new ContainerElement({
    width: 15,
    height: 10,
    style: {
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'space-between'
    }
  }, [child1, child2]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 15, height: 10 },
    parentBounds: { x: 0, y: 0, width: 15, height: 10 },
    availableSpace: { width: 15, height: 10 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 2);
  assertEquals(layoutTree.children[0].bounds.y, 0);
  assert(layoutTree.children[1].bounds.y > layoutTree.children[0].bounds.y);
});

Deno.test('Flexbox justify-content center', () => {
  const engine = new LayoutEngine();

  const child = new TextElement({ text: 'Centered' });

  const container = new ContainerElement({
    width: 20,
    height: 5,
    style: {
      display: 'flex',
      justifyContent: 'center'
    }
  }, [child]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 20, height: 5 },
    parentBounds: { x: 0, y: 0, width: 20, height: 5 },
    availableSpace: { width: 20, height: 5 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 1);

  // Child should be centered horizontally
  const child1 = layoutTree.children[0];
  const expectedX = (20 - child1.bounds.width) / 2;
  assert(Math.abs(child1.bounds.x - expectedX) < 1);
});

Deno.test('Basic grid layout with explicit columns/rows', () => {
  const engine = new LayoutEngine();

  const children = [
    new TextElement({ text: 'A' }),
    new TextElement({ text: 'B' }),
    new TextElement({ text: 'C' }),
    new TextElement({ text: 'D' }),
  ];

  const container = new ContainerElement({
    width: 20,
    height: 10,
    style: {
      display: 'grid',
      gridTemplateColumns: [5, 5], // 2 columns: 5px, 5px
      gridTemplateRows: [5, 5] // 2 rows: 5px, 5px
    }
  }, children);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 20, height: 10 },
    parentBounds: { x: 0, y: 0, width: 20, height: 10 },
    availableSpace: { width: 20, height: 10 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 4);

  // Check grid positioning
  const [a, b, c, d] = layoutTree.children;

  // First row
  assertEquals(a.bounds.x, 0);
  assertEquals(a.bounds.y, 0);
  assertEquals(a.bounds.width, 5);

  assertEquals(b.bounds.x, 5);
  assertEquals(b.bounds.y, 0);
  assertEquals(b.bounds.width, 5);

  // Second row
  assertEquals(c.bounds.x, 0);
  assertEquals(c.bounds.y, 5);
  assertEquals(c.bounds.width, 5);

  assertEquals(d.bounds.x, 5);
  assertEquals(d.bounds.y, 5);
  assertEquals(d.bounds.width, 5);
});

Deno.test('Grid layout with fr units', () => {
  const engine = new LayoutEngine();

  const children = [
    new TextElement({ text: 'A' }),
    new TextElement({ text: 'B' }),
  ];

  const container = new ContainerElement({
    width: 20,
    height: 10,
    style: {
      display: 'grid',
      gridTemplateColumns: '1fr 2fr', // Column 1: 1/3 width, Column 2: 2/3 width
      gridTemplateRows: '1fr'
    }
  }, children);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 20, height: 10 },
    parentBounds: { x: 0, y: 0, width: 20, height: 10 },
    availableSpace: { width: 20, height: 10 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 2);

  const [a, b] = layoutTree.children;

  // Check fractional sizing
  assert(Math.abs(a.bounds.width - (20 / 3)) < 1);
  assert(Math.abs(b.bounds.width - (40 / 3)) < 1);

  assertEquals(a.bounds.x, 0);
  assert(Math.abs(b.bounds.x - a.bounds.width) < 1);
});

Deno.test('Grid layout with gaps', () => {
  const engine = new LayoutEngine();

  const children = [
    new TextElement({ text: 'A' }),
    new TextElement({ text: 'B' }),
    new TextElement({ text: 'C' }),
    new TextElement({ text: 'D' }),
  ];

  const container = new ContainerElement({
    width: 22,
    height: 12,
    style: {
      display: 'grid',
      gridTemplateColumns: [10, 10], // 2 columns
      gridTemplateRows: [5, 5], // 2 rows
      gridColumnGap: 2,
      gridRowGap: 2
    }
  }, children);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 22, height: 12 },
    parentBounds: { x: 0, y: 0, width: 22, height: 12 },
    availableSpace: { width: 22, height: 12 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 4);

  const [a, b, c, d] = layoutTree.children;

  // Check gap spacing
  assertEquals(a.bounds.x, 0);
  assertEquals(b.bounds.x, 12); // 10 + 2 (gap)
  assertEquals(c.bounds.y, 7);  // 5 + 2 (gap)
  assertEquals(d.bounds.y, 7);  // 5 + 2 (gap)
});

Deno.test('Grid explicit item placement', () => {
  const engine = new LayoutEngine();

  const itemA = new TextElement({
    text: 'A',
    gridColumn: [1, 3], // Spans from column 1 to 3
    gridRow: 1,
  });

  const itemB = new TextElement({
    text: 'B',
    gridColumn: 2,
    gridRow: 2,
  });

  const container = new ContainerElement({
    width: 30,
    height: 20,
    style: {
      display: 'grid',
      gridTemplateColumns: [10, 10, 10], // 3 columns
      gridTemplateRows: [10, 10] // 2 rows
    }
  }, [itemA, itemB]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 30, height: 20 },
    parentBounds: { x: 0, y: 0, width: 30, height: 20 },
    availableSpace: { width: 30, height: 20 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 2);

  const [a, b] = layoutTree.children;

  // Item A should span 2 columns
  assertEquals(a.bounds.x, 0);
  assertEquals(a.bounds.width, 20); // Should span 2 columns

  // Item B should be in second column, second row
  assertEquals(b.bounds.x, 10);
  assertEquals(b.bounds.y, 10);
});

Deno.test('Absolute positioning', () => {
  const engine = new LayoutEngine();

  const absoluteChild = new TextElement({
    text: 'Absolute',
    width: 15,
    height: 3,
    style: {
      position: 'absolute',
      top: 5,
      left: 10
    }
  });

  const normalChild = new TextElement({ text: 'Normal' });

  const container = new ContainerElement({
    width: 50,
    height: 30,
    style: { position: 'relative' }
  }, [normalChild, absoluteChild]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 50, height: 30 },
    parentBounds: { x: 0, y: 0, width: 50, height: 30 },
    availableSpace: { width: 50, height: 30 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 2);

  // Find the absolute and normal children
  const normalNode = layoutTree.children.find(child =>
    (child.element as any).props.text === 'Normal'
  );
  const absoluteNode = layoutTree.children.find(child =>
    (child.element as any).props.text === 'Absolute'
  );

  assert(normalNode);
  assert(absoluteNode);

  // Normal child should be at origin
  assertEquals(normalNode.bounds.x, 0);
  assertEquals(normalNode.bounds.y, 0);

  // Absolute child should be positioned according to top/left
  assertEquals(absoluteNode.bounds.x, 10);
  assertEquals(absoluteNode.bounds.y, 5);
  assertEquals(absoluteNode.bounds.width, 15);
  assertEquals(absoluteNode.bounds.height, 3);
});

Deno.test('Z-index layering', () => {
  const engine = new LayoutEngine();

  const child1 = new TextElement({ text: 'Back', zIndex: 1 });
  const child2 = new TextElement({ text: 'Front', zIndex: 10 });
  const child3 = new TextElement({ text: 'Middle', zIndex: 5 });

  const container = new ContainerElement({
    width: 20,
    height: 10,
  }, [child1, child2, child3]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 20, height: 10 },
    parentBounds: { x: 0, y: 0, width: 20, height: 10 },
    availableSpace: { width: 20, height: 10 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 3);

  // Check z-index values are preserved
  const zIndexes = layoutTree.children.map(child => child.zIndex);
  assert(zIndexes.includes(1));
  assert(zIndexes.includes(5));
  assert(zIndexes.includes(10));
});

Deno.test('Complex nested layout', () => {
  const engine = new LayoutEngine();

  // Create a complex layout with nested containers
  const flexItems = [
    new TextElement({ text: 'Flex Item 1', flexGrow: 1 }),
    new TextElement({ text: 'Flex Item 2', flexGrow: 2 }),
  ];

  const flexContainer = new ContainerElement({
    height: 5,
    style: {
      display: 'flex',
      flexDirection: 'row'
    }
  }, flexItems);

  const gridItems = [
    new TextElement({ text: 'Grid A' }),
    new TextElement({ text: 'Grid B' }),
    new TextElement({ text: 'Grid C' }),
    new TextElement({ text: 'Grid D' }),
  ];

  const gridContainer = new ContainerElement({
    height: 6,
    style: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gridTemplateRows: [3, 3]
    }
  }, gridItems);

  const mainContainer = new ContainerElement({
    width: 30,
    height: 15,
    style: { display: 'block' }
  }, [flexContainer, gridContainer]);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 30, height: 15 },
    parentBounds: { x: 0, y: 0, width: 30, height: 15 },
    availableSpace: { width: 30, height: 15 },
  };

  const layoutTree = engine.calculateLayout(mainContainer, context);

  assertEquals(layoutTree.children.length, 2);

  const flexNode = layoutTree.children[0];
  const gridNode = layoutTree.children[1];

  // Flex container should have 2 children
  assertEquals(flexNode.children.length, 2);

  // Grid container should have 4 children
  assertEquals(gridNode.children.length, 4);

  // Flex container should be at top
  assertEquals(flexNode.bounds.y, 0);
  assertEquals(flexNode.bounds.height, 5);

  // Grid container should be below flex container
  assertEquals(gridNode.bounds.y, flexNode.bounds.height);
  assertEquals(gridNode.bounds.height, 6);
});

Deno.test('Grid auto-flow column', () => {
  const engine = new LayoutEngine();

  const children = [
    new TextElement({ text: 'A' }),
    new TextElement({ text: 'B' }),
    new TextElement({ text: 'C' }),
  ];

  const container = new ContainerElement({
    width: 15,
    height: 10,
    style: {
      display: 'grid',
      gridTemplateColumns: [5, 5, 5],
      gridTemplateRows: [5, 5],
      gridAutoFlow: 'column'
    }
  }, children);

  const context: LayoutContext = {
    viewport: { x: 0, y: 0, width: 15, height: 10 },
    parentBounds: { x: 0, y: 0, width: 15, height: 10 },
    availableSpace: { width: 15, height: 10 },
  };

  const layoutTree = engine.calculateLayout(container, context);

  assertEquals(layoutTree.children.length, 3);

  const [a, b, c] = layoutTree.children;

  // With column auto-flow, items should fill columns first
  assertEquals(a.bounds.x, 0);
  assertEquals(a.bounds.y, 0);

  assertEquals(b.bounds.x, 0);
  assertEquals(b.bounds.y, 5);

  assertEquals(c.bounds.x, 5);
  assertEquals(c.bounds.y, 0);
});

Deno.test('Global layout engine instance', () => {
  assert(globalLayoutEngine);
  assert(globalLayoutEngine instanceof LayoutEngine);
});